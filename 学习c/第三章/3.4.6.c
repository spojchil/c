// 2025 5 4 float、double和long double
/*
float至少表示六位有效数字，取值范围是1.0e-37~1.0e37
至少精确小数点后6位有效数字
通常储存一个浮点数要占用32位。八位用于表示指数的值和符号
剩下24位表示非指数部分（也叫做尾数或有效数）及其符号

另一种浮点数类型是double双精度
double占用64位，至少有13位有效数字
默认编译器假定的浮点型常量是double类型的精度
假设some是float
some = 4.0 *2.0 使用双精度计算，然后截断为float

以 some = 4.0 * 2.0 为例：

​​计算​​：4.0 * 2.0 = 8.0（double）。
double的8.0表示为：
符号位: 0
指数: 1023 + 3 = 1026 (二进制 10000000010)
尾数: 1.000...000 (52位)
​​转换​​：
指数调整：1026 - 1023 + 127 = 130 → 10000010（8位）。
尾数截断：保留前23位（全0）。
结果：
符号位: 0
指数: 10000010
尾数: 000...000
对应float的8.0，无精度损失。

可以
float some = 4.0f * 2.0f;
直接以float精度计算，避免截断
后缀L使数字成为long double类型

1. 语法格式​​
十六进制浮点型常量的通用格式为：
​​0x​​<整数部分>​​.​​<小数部分>​​p​​<指数部分>

​​0x 或 0X​​：十六进制前缀。
​​p 或 P​​：表示“2的幂”（类似十进制科学计数法的e或E，但基数为2而非10）。
​​示例​​：0xa.1fp10
​​2. 示例解析：0xa.1fp10​​
​​(1) 分解各部分​​
​​整数部分（a）​​：
a（十六进制）= 10（十进制）。
​​小数部分（.1f）​​：
.1 = 1/16（即16⁻¹）。
f = 15/256（即15×16⁻²）。
合计：1/16 + 15/256 = 0.12109375。
​​指数部分（p10）​​：
2¹⁰ = 1024。
​​(2) 计算最终值​​
(10 + 0.12109375) × 1024 =
 10.12109375 × 1024 = 10364.0

​​核心规则​​：
0x[十六进制数]p[十进制指数]
*/

#include <stdio.h>
int main(void)
{
    float aboat = 32000.0;
    double abet = 2.14e9;
    long double dip = 5.32e-5;

    printf("%f 可以写成%e\n", aboat, aboat);
    printf("也是可以写成16进制格式%a\n", aboat);
    printf("%f 可以写成%e\n", abet, abet);
    printf("%Lf可以写成%Le\n", dip, dip);  // 插曲见难题

    float 太大 = 3.4e38 * 100.0f;

    printf("%e\n", 太大);  //超出了范围显示inf

    float 小值 = 1.175494e-38;

    printf("%f %e\n", 小值, 小值);  // 0.000000 1.175494e-38
    printf("%e %e\n", 小值 / 1.0e8f, 小值 / 1.0e7f);  // 0.000000e+00 1.401298e-45
    printf("%e %e\n", 小值 / 1.0e285, 小值 / 1.0e286);  // 9.881313e-324 0.000000e+00
    // 在第三行隐式提升为 double 运算​​

    float a,b;

    b = 2.0e20 + 1.0;
    a = b - 2.0e20;
    printf("%f \n", a);  // 输出4008175468544.000000浮点数舍人错误
    return 0;
}
// 由于使用了较新的标准C17所以输出保留了更精准的位数