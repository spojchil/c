// 多维数组
/*
float rain[5][12];
包含五个数组元素的数组
rain[5]  是一个包含五个元素的数组
float       [12]  一个包含12个float类型元素的数组
也就是rain的每个元素本身都是一个包含12个float类的数值的数组
那么就得知rain[0]是一个数组，那么它的首元素就是rain[0][0]
*/
#include <stdio.h>
#define 月数 12
#define 年数 5

void 指针地址(void);
void 降水量(void);
void 月日3(void);

int main(void){
    // 降水量();
    // 指针地址();
    月日3();
    return 0;
}

void 降水量(void)
{
    const float rain[年数][月数] = {
        {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
        {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3},
        {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4},
        {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
        {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}};
    // 可以省略内部大括号但是必须保证数量匹配，否则就会顺序匹配
    // 同一维数组部分初始化的，未初始化到赋值为0
    int 年, 月;
    float 小计, 总共;

    printf(" YEAR   RAINFALL    (inches)\n");
    for (年 = 0, 总共 = 0; 年 < 年数; 年++)
    {
        for (月 = 0, 小计 = 0; 月 < 月数; 月++)
            小计 += rain[年][月];
        printf("%5d %15.1f\n", 2010 + 年, 小计);
        总共 += 小计;
    }
    printf("\n这%d年的平均值是%.1f\n\n", 年数, 总共 / 年数);
    printf("月平均:\n\n");
    printf(" 一月 二月 三月 四月 五月 六月 ");
    printf("七月 八月 九月 十月 11月 12月\n");

    for (月 = 0; 月 < 月数; 月++)
    {
        for (年 = 0, 小计 = 0; 年 < 年数; 年++)
            小计 += rain[年][月];

        printf("%4.1f ", 小计 / 年数);
    }
    printf("\n");
}

#define 尺寸 4
void 指针地址(void)
{
    short 数据[尺寸];
    short *pti;
    short 索引;
    double 账单[尺寸];
    double *ptf;
    pti = 数据;
    ptf = 账单;

    printf("指针大小: %zu字节 (应该是8就是64位)\n", sizeof(void *));

    printf("%23s %15s\n", "short", "double");
    for (索引 = 0; 索引 < 尺寸; 索引++)
        printf("pointers + %d:  %10p %10p\n", 索引, pti + 索引, ptf + 索引);
    // 这里打印的是短地址无前导0，不过也可以看
    // 对指针使用+1，递增的不是1而是指针所指类型的尺寸
    // dates + 2 == &dates[2]相同的地址
    // *(dates + 2) == dates[2]相同的值
}

void 月日3(void)
{
    int 天数[月数] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int 索引;

    for (索引 = 0; 索引 < 月数; 索引++)
        printf("%2d月有%2d天。\n", 索引 + 1,
               *(天数 + 索引));
}