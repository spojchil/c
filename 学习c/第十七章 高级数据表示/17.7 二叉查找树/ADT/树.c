#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "树.h"

#include <assert.h>

typedef struct A对节点{
    节点 *父节点;
    节点 *目标节点;
    bool 是左节点;
} 对节点;

void 初始化树(树 *树指针){
    树指针->根指针 = NULL;
    树指针->项数 = 0;
}

bool 树是否为空(const 树 *树指针){
    if (树指针->根指针 == NULL)
        return true;
    return false;
}
static bool 去左边(const 项 *, const 项 *);

static bool 去左边(const 项 *项指针, const 项 *树中项){
    int 比较值;
    
    if ((比较值 = strcmp(项指针->宠物名, 树中项->宠物名)) < 0)
        return true;
    else if (比较值 == 0 && strcmp(项指针->宠物种类, 树中项->宠物种类) < 0)
        return true;
    else
        return false;
}

static bool 去右边(const 项 *, const 项 *);

static bool 去右边(const 项 *项指针, const 项 *树中项){
    int 比较值;
    
    if ((比较值 = strcmp(项指针->宠物名, 树中项->宠物名)) > 0)
        return true;
    else if (比较值 == 0 && strcmp(项指针->宠物种类, 树中项->宠物种类) > 0)
        return true;
    else
        return false;
}

static 对节点 项查找(const 项 *项指针, const 树 *树指针){
    // 所有会用到是左节点的场景，该字段都会被循环内的逻辑显式赋值
    对节点 目标 = {NULL, 树指针->根指针};

    if (目标.目标节点 == NULL)
        return 目标;

    while (目标.目标节点 != NULL){
        if (去左边(项指针, &(目标.目标节点->项值))){
            目标.父节点 = 目标.目标节点;
            目标.目标节点 = 目标.目标节点->左节点;
            目标.是左节点 = true;
        }
        else if (去右边(项指针, &(目标.目标节点->项值))){
            目标.父节点 = 目标.目标节点;
            目标.目标节点 = 目标.目标节点->右节点;
            目标.是左节点 = false;
        }
        else
            break;
    }

    return 目标;
}

bool 项是否存在(const 项 *项指针, const 树 *树指针){
    return (项查找(项指针, 树指针).目标节点 == NULL ? false : true);
}

int 树的项数(const 树 *树指针){
    return 树指针->项数;
}

static 节点 *创建新节点(const 项 *项指针);

static 节点 *创建新节点(const 项 *项指针){
    节点 *新节点 = malloc(sizeof(节点));

    if (新节点 != NULL){
        新节点->项值 = *项指针;
        新节点->左节点 = NULL;
        新节点->右节点 = NULL;
    }

    return 新节点;
}

bool 树是否已满(const 树 *树指针){
    // 测试时
    if (树指针->项数 >= 最多项数)
        return true;
    // 发表时
    // 修改为检测内存分配
    return false;
}

bool 增加项(const 项 *项指针, 树 *树指针){
    if (树是否为空(树指针)){
        节点 *新节点 = 创建新节点(项指针);
        if (新节点 == NULL){
            fprintf(stderr, "内存分配失败\n");
            return false;
        }
        树指针->根指针 = 新节点;
        树指针->项数++;
        return true;
    }
    
    if (树是否已满(树指针)){
        fprintf(stderr, "树已满\n");
        return false;
    }

    对节点 临时对 = 项查找(项指针, 树指针);
    if (临时对.目标节点 != NULL){
        fprintf(stderr, "项已存在\n");
        return false;
    }

    节点 *新节点 = 创建新节点(项指针);
    if (新节点 == NULL){
        fprintf(stderr, "内存分配失败\n");
        return false;
    }

    if (临时对.是左节点)
        临时对.父节点->左节点 = 新节点;
    else 
        临时对.父节点->右节点 = 新节点;

    树指针->项数++;
    return true;
}

static 对节点 寻找最小节点(节点 *节点指针);

static 对节点 寻找最小节点(节点 *节点指针){
    // 所有调用本函数的传入指针都不可能为空
    assert(节点指针 != NULL && "寻找传入为空");

    对节点 目标 = {NULL, 节点指针};

    // 存在一种情况，当传入的右子树的根节点的左节点为空
    // 此时不进入循环，直接返回，且此时的父节点为NULL
    while (目标.目标节点->左节点 != NULL){
        目标.父节点 = 目标.目标节点;
        目标.目标节点 = 目标.目标节点->左节点;
    }

    return 目标;
}

static void 删除子节点(对节点 *对指针, 树 *树指针);

static void 删除子节点(对节点 *对指针, 树 *树指针){
    if (对指针->目标节点->左节点 == NULL){
        if (对指针->是左节点)
            对指针->父节点->左节点 = 对指针->目标节点->右节点;
        else
            对指针->父节点->右节点 = 对指针->目标节点->右节点;
    }
    else if (对指针->目标节点->右节点 == NULL){
        if (对指针->是左节点)
            对指针->父节点->左节点 = 对指针->目标节点->左节点;
        else
            对指针->父节点->右节点 = 对指针->目标节点->左节点;
    }
    else {
        // 传入右子树
        对节点 临时对 = 寻找最小节点(对指针->目标节点->右节点);

        // 右子树的根节点就是最小节点,即临时对的父节点为空
        if (临时对.父节点 == NULL){
            // 值复制或许更简单一点
            if (对指针->是左节点)
                对指针->父节点->左节点 = 临时对.目标节点;
            else
                对指针->父节点->右节点 = 临时对.目标节点;
            // 将原来的左子树接在原来的右子树的根节点的左边
            临时对.目标节点->左节点 = 对指针->目标节点->左节点;

        }
        else {
            if (对指针->是左节点)
                对指针->父节点->左节点 = 临时对.目标节点;
            else 
                对指针->父节点->右节点 = 临时对.目标节点;
            临时对.父节点->左节点 = 临时对.目标节点->右节点;
            临时对.目标节点->右节点 = 对指针->目标节点->右节点;
            临时对.目标节点->左节点 = 对指针->目标节点->左节点;
        }
    }
    free(对指针->目标节点);
}

static void 删除根节点(树 *);

static void 删除根节点(树 *树指针){
    if (树指针->根指针->右节点 == NULL){
        节点 *临时 = 树指针->根指针;
        树指针->根指针 = 树指针->根指针->左节点;
        free(临时);
        return;
    }
    对节点 临时对 = 寻找最小节点(树指针->根指针->右节点);
    if (临时对.父节点 == NULL){
        临时对.目标节点->左节点 = 树指针->根指针->左节点;
        free(树指针->根指针);
        树指针->根指针 = 临时对.目标节点;
    }
    else {
        临时对.父节点->左节点 = 临时对.目标节点->右节点;
        临时对.目标节点->左节点 = 树指针->根指针->左节点;
        临时对.目标节点->右节点 = 树指针->根指针->右节点;
        free(树指针->根指针);
        树指针->根指针 = 临时对.目标节点;
    }
}

bool 删除项(const 项 *项指针, 树 *树指针){
    if (树是否为空(树指针)){
        fprintf(stderr, "树为空\n");
        return false;
    }
    对节点 临时对 = 项查找(项指针, 树指针);
    if (临时对.目标节点 == NULL){
        fprintf(stderr, "项不存在\n");
        return false;
    }
    if (临时对.父节点 == NULL){
        删除根节点(树指针);
        树指针->项数--;
        return true;
    }
    删除子节点(&临时对, 树指针);
    树指针->项数--;
    
    return true;
}

static void 中序遍历(const 节点 *节点指针, void (*项函数)(项));

static void 中序遍历(const 节点 *节点指针, void (*项函数)(项)){
    if (节点指针 != NULL){
        中序遍历(节点指针->左节点, 项函数);
        项函数(节点指针->项值);
        中序遍历(节点指针->右节点, 项函数);
    }
}

void 项函数应用(const 树 *树指针, void (*项函数)(项)){
    if (树指针 != NULL)
        中序遍历(树指针->根指针, 项函数);
}

static void 删除所有节点(节点 *节点指针){
    if (节点指针 != NULL){
        删除所有节点(节点指针->左节点);
        删除所有节点(节点指针->右节点);
        free(节点指针);
    }
}

void 删除树(树 *树指针){
    删除所有节点(树指针->根指针);
    树指针->根指针 = NULL;
    树指针->项数 = 0;
}
