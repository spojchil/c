/*
类型转换
类型转换的级别从高到低是浮点数大于整数
长的大于短的无符号的大于有符号的
如long long,unsign long,long
作为函数参数传递时，char和short都会被准换为int,float准换为double


1. 整数类型不匹配时的转换规则​​
​​无符号整型（如 unsigned char）​​
若待赋的值是整数且超出目标类型范围，​​高位会被直接截断​​，实际存储值为原始值对目标类型最大值+1取模。
​​示例​​：将 300（二进制 100101100）赋给 8 位 unsigned char（范围 0~255）时，
结果为 300 % 256 = 44（二进制 00101100，高位 1 被丢弃）。
​​有符号整型（如 int）​​
若待赋的值是整数且超出范围，​​行为由编译器实现决定​​。可能是截断、环绕（溢出），甚至触发未定义行为（UB）。
​​注意​​：不同编译器可能处理不同，需谨慎避免此类情况。
​​整型目标 + 浮点数来源​​
直接赋浮点数给整型是​​未定义行为（UB）​​，程序可能崩溃或输出任意值。应显式转换（如强制类型转换）。
​​2. 浮点数转换为整数类型的规则​​
​​截断规则（Truncation）​​
浮点数转换为整数时，​​直接丢弃小数部分​​，仅保留整数部分（向零取整）。
​​示例​​：
23.12 → 23
23.99 → 23
-23.5 → -23（非四舍五入）
​​潜在问题​​
若浮点数值超出目标整型范围（如 1e10 赋给 int），
结果是​​未定义的​​，可能引发错误或存储错误值。
*/
#include <stdio.h>
int 类型转换(void);
void 参数使用(void);
void 含参函数(int n);
int main(void)
{
    // 类型转换();
    参数使用();
    return 0;
}

int 类型转换(void)
{
    char ch;
    int i;
    float fl;

    fl = i = ch = 'C';  // i为整数67,fl为浮点数67.00，此时的67.00是精确的
    printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl);
    ch = ch + 1;  // 字符变量'c'被转换成整数67，然后加1，然后被截断为1字节储存在ch中
    i = fl + 2 * ch;  // ch转换为4字节整数然后乘2，然后转换为浮点数，最后结果转换为整数
    fl = 2.0 * ch + i;  // ch转换为浮点数68.00，然后i转换为浮点数203.00与其相加
    printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl);
    ch = 1107;  // 超过的位数直接截断，值为1107 % 256即63
    printf("新的ch = %c\n", ch);
    ch = 80.89;  // 降级
    printf("新的ch = %c\n", ch);

    int mice;
    mice = 1.6 + 1.7;
    printf("%d", mice);  // 值为3
    mice = (int)1.6 + (int)1.7;  // 强制类型转换 值为2
    printf("%d", mice);

    return 0;  // 修正此处冗余且无实际意义，应使用void
}

void 参数使用(void)
{
    int times = 5;
    char ch = '!';
    float f = 6.0f;

    含参函数(times);  // int类型
    含参函数(ch);  // 等价于含参函数((int)ch);
    含参函数(f);  // 等价于含参函数((int)f);
}

void 含参函数(int n)  // 这个n是这个函数私有的
{
    while (n-- > 0)
        printf("#");
    printf("\n");
}
// 声明参数创建了形式参数int类型的n,含参函数(10)这样的调用会把10赋给n
// 函数调用传递的值成为实际参数